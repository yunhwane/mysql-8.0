## 캐싱을 통한 애플리케이션 공통 코드 조회 단점 극복

### 공통 코드 특성
- 데이터가 매우 작다(그룹이 50개고 평균 250개이다)
- 변경이 거의 없다.
- 조회가 매우 빈번하다.
즉 데이터 크기는 매우 작고, 변경 빈도는 매우 낮고, 조회 빈도는 매우 높다

메모리 접근과 네트워크 접근의 차이는 약 5,000배다. 실제로는 네트워크 지연, 데이터베이스 처리 시간 등이 추가되어
그 차이는 훨씬 더 커진다. 데이터베이스는 보통 같은 데이터센터에 별도의 서버로 구성되어 있으므로 애플리케이션에
서 네트워크 통신이 필요하다.


- **메모리 호출**: 거의 공짜
- **네트워크 호출 (DB 조회)**: 비용이 큼
공통 코드를 메모리에 캐싱해두면, 네트워크 호출 없이 즉시 코드 이름을 조회할 수 있다.


로컬 메모리 캐싱
``` java
class CommonCodeCache {
       private Map<String, Map<String, String>> cache;

      void init() {
          List<CommonCode> codes = db.query(
              "SELECT group_code, code, name FROM common_code_detail WHERE use_yn = 'Y'");

      for (code in codes) {
              cache[code.groupCode][code.code] = code.name;
      }
}

  
String getName(String groupCode, String code) {
    return cache[groupCode][code];
    }
}
```

## 내가 지금 겪고 있는 캐싱 동기화 문제 해결 방안
1. 애플리케이션 시작 시 공통 코드 캐시에 로딩
2. 운영중 관리자가 데이터베이스의 공통 코드 테이블에 주문 접수를 주문 완료로 변경
3. 데이터베이스는 변경되었지만 캐시는 여전히 주문 접수


### 해결 방안
#### 관리자 페이지에서 캐시 갱신
```java
// 관리자 페이지: 공통 코드 수정
void updateCommonCode(String groupCode, String code, String newName) {
// 1. DB 업데이트
db.execute("UPDATE common_code_detail SET name = ? WHERE group_code = ?
AND code = ?",
newName, groupCode, code);
// 2. 캐시 갱신
CommonCodeCache.refresh();
}
```
- 다중 서버일경우 다른 서버의 동기화가 되지 않는다.

#### 모든 서버에서 갱신 요청
```
// 관리자 페이지: 공통 코드 수정
void updateCommonCode(String groupCode, String code, String newName) {
// 1. DB 업데이트
db.execute("UPDATE ...");
// 2. 모든 서버에 캐시 갱신 요청
for (server in getAllServers()) {
    http.post(server + "/cache/refresh");
    }
}
```
- 모든 서버 목록을 관리해야 한다.
- 서버가 추가/제거 될때마다 목록을 업데이트해야한다.
- 일부 서버에서 요청을 실패하면 어떻게 처리할 것인가?
- 서버가 수백대라면 수백번의 HTTP 요청이 필요하다.

#### Redis 중앙 캐시 사용
- 중앙에 Redis 같은 캐시 서버를 두고, 모든 애플리케이션 서버가 이 캐시를 공유하는 방법이 있다.
- 참고로 Redis를 단순하게 말하면 데이터를 메모리에 올려서 사용하는 캐시 용도의 응답이 매우 빠른 서버로 이해하면 된다.


- Redis 캐시의 한계
  - Redis를 사용하면 동기화 문제는 해결되지만, 원래 문제가 다시 발생한다. Redis 조회도 **네트워크 호출**이기 때문이다.

### TTL 을 활용한 최적화 전략
- **로컬 캐시 + TTL(Time To Live)** 전략

```java
class CommonCodeCache {
    private Map<String, Map<String, String>> cache;
    private DateTime lastLoadTime;
    private int TTL_SECONDS = 60; // 1분
    String getName(String groupCode, String code) {
    // TTL 만료 확인
    if (isExpired()) {
        refresh(); // 캐시 갱신
    }
    return cache[groupCode][code];

    boolean isExpired() {
        return (now() - lastLoadTime) > TTL_SECONDS;
    }
    void refresh() {
        // DB에서 다시 로딩
        cache = loadFromDatabase();
        lastLoadTime = now();
    }
}
```

## TTL 전략의 동작 방식
```
시간 00:00 - 서버 A 시작, 캐시 로딩 (ORDER: 주문접수)
시간 00:30 - 관리자가 DB 수정 (ORDER: 주문완료)
시간 00:30 - 서버 A 캐시: 여전히 '주문접수' (TTL 만료 전)
시간 01:00 - 서버 A TTL 만료, 캐시 갱신 (ORDER: 주문완료)
```

- 관리자가 수정하고 최대 1분 후에는 모든 서버에 변경 사항이 반영된다. 결과적으로 모든 서버가 1분에 1번씩만 공통 코드 값을 갱신하기 위해 데이터베이스를 조회하게 된다.
### 1분이면 충분한가?
- 운영 관점에서 1분은 충분히 수용 가능한 지연 시간이다.

### 로컬 캐시 + TTL의 장점
- 네트워크 호출 없이 메모리에서 즉시 조회
- TTL 만료 시 자동으로 데이터베이스와 동기화
- 다중 서버 환경에서도 복잡한 동기화 로직 불필요
- 구현이 상대적으로 간단
## 권장 TTL 값
- 일반적인 경우: 60초 (1분)
- 빠른 반영이 필요한 경우: 10~30초
- 변경이 거의 없는 경우: 300초 (5분) 이상
